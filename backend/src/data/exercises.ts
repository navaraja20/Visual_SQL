export interface Exercise {
  id: string;
  moduleId: string;
  type: 'write-query' | 'multiple-choice' | 'predict-result';
  title: string;
  description: string;
  difficulty: 'easy' | 'medium' | 'hard';
  schema: string;
  question: string;
  options?: Array<{ id: string; text: string }>;
  answer: string | number;
  expectedResult?: any;
  hints?: string[];
}

export const exercises: Exercise[] = [
  {
    id: 'ex-select-01',
    moduleId: 'select-from',
    type: 'write-query',
    title: 'Select All Columns',
    description: 'Write a query to select all columns from the employees table',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a SQL query to retrieve all columns and all rows from the employees table.',
    answer: 'SELECT * FROM employees',
    hints: ['Use the * wildcard to select all columns', 'The basic syntax is SELECT columns FROM table'],
  },
  {
    id: 'ex-select-02',
    moduleId: 'select-from',
    type: 'write-query',
    title: 'Select Specific Columns',
    description: 'Select only name and salary columns',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to select only the name and salary columns from the employees table.',
    answer: 'SELECT name, salary FROM employees',
    hints: ['List the column names separated by commas', 'Column order matters in the result'],
  },
  {
    id: 'ex-where-01',
    moduleId: 'where-clause',
    type: 'write-query',
    title: 'Filter by Salary',
    description: 'Find employees with salary greater than 100000',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find all employees whose salary is greater than 100000.',
    answer: 'SELECT * FROM employees WHERE salary > 100000',
    hints: ['Use the WHERE clause to filter', 'Use the > operator for greater than comparisons'],
  },
  {
    id: 'ex-where-02',
    moduleId: 'where-clause',
    type: 'multiple-choice',
    title: 'WHERE Clause Concept',
    description: 'Understanding when WHERE is evaluated',
    difficulty: 'easy',
    schema: 'employees',
    question: 'When is the WHERE clause evaluated in a SELECT query?',
    options: [
      { id: 'a', text: 'After SELECT' },
      { id: 'b', text: 'Before SELECT' },
      { id: 'c', text: 'After ORDER BY' },
      { id: 'd', text: 'It depends on the query' },
    ],
    answer: 'b',
  },
  {
    id: 'ex-logical-01',
    moduleId: 'logical-operators',
    type: 'write-query',
    title: 'AND Operator',
    description: 'Find engineers with high salaries',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find employees in department 1 (Engineering) who earn more than 100000.',
    answer: 'SELECT * FROM employees WHERE dept_id = 1 AND salary > 100000',
    hints: ['Use AND to combine two conditions', 'Both conditions must be true'],
  },
  {
    id: 'ex-logical-02',
    moduleId: 'logical-operators',
    type: 'write-query',
    title: 'OR Operator',
    description: 'Find employees in multiple departments',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find employees who work in either department 2 (Sales) or department 3 (Marketing).',
    answer: 'SELECT * FROM employees WHERE dept_id = 2 OR dept_id = 3',
    hints: ['Use OR to match either condition', 'At least one condition must be true'],
  },
  {
    id: 'ex-orderby-01',
    moduleId: 'order-by',
    type: 'write-query',
    title: 'Sort Descending',
    description: 'List employees by salary from highest to lowest',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to list all employees sorted by salary from highest to lowest.',
    answer: 'SELECT * FROM employees ORDER BY salary DESC',
    hints: ['Use ORDER BY to sort results', 'Use DESC for descending order (largest first)'],
  },
  {
    id: 'ex-orderby-02',
    moduleId: 'order-by',
    type: 'write-query',
    title: 'Multi-level Sort',
    description: 'Sort by department then salary',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to list employees sorted first by dept_id (ascending), then by salary (descending) within each department.',
    answer: 'SELECT * FROM employees ORDER BY dept_id ASC, salary DESC',
    hints: ['You can sort by multiple columns', 'Separate columns with commas', 'Specify ASC or DESC for each'],
  },
  {
    id: 'ex-join-01',
    moduleId: 'inner-join',
    type: 'write-query',
    title: 'Basic INNER JOIN',
    description: 'Join employees with departments',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to show employee names along with their department names. Only include employees who have a department.',
    answer: 'SELECT e.name, d.name AS department FROM employees e INNER JOIN departments d ON e.dept_id = d.id',
    hints: ['Use INNER JOIN to combine tables', 'Join ON the foreign key relationship', 'Use aliases to shorten table names'],
  },
  {
    id: 'ex-join-02',
    moduleId: 'inner-join',
    type: 'multiple-choice',
    title: 'INNER JOIN Behavior',
    description: 'Understanding what INNER JOIN returns',
    difficulty: 'easy',
    schema: 'employees',
    question: 'What happens to rows from the left table that don\'t have a match in the right table with INNER JOIN?',
    options: [
      { id: 'a', text: 'They are included with NULL values' },
      { id: 'b', text: 'They are excluded from the result' },
      { id: 'c', text: 'They cause an error' },
      { id: 'd', text: 'They are duplicated' },
    ],
    answer: 'b',
  },
  {
    id: 'ex-leftjoin-01',
    moduleId: 'left-join',
    type: 'write-query',
    title: 'LEFT JOIN All Employees',
    description: 'Include all employees even without departments',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to show all employees with their department names. Include employees who don\'t have a department.',
    answer: 'SELECT e.name, d.name AS department FROM employees e LEFT JOIN departments d ON e.dept_id = d.id',
    hints: ['Use LEFT JOIN to include all left table rows', 'Unmatched rows will have NULL for right table columns'],
  },
  {
    id: 'ex-leftjoin-02',
    moduleId: 'left-join',
    type: 'write-query',
    title: 'Find Unmatched Records',
    description: 'Find employees without departments',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to find employees who are NOT assigned to any department.',
    answer: 'SELECT e.name FROM employees e LEFT JOIN departments d ON e.dept_id = d.id WHERE d.id IS NULL',
    hints: ['Use LEFT JOIN and then filter for NULLs', 'Check if the right table\'s primary key IS NULL'],
  },
  {
    id: 'ex-groupby-01',
    moduleId: 'group-by',
    type: 'write-query',
    title: 'Count by Group',
    description: 'Count employees per department',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to count how many employees are in each department.',
    answer: 'SELECT dept_id, COUNT(*) AS employee_count FROM employees GROUP BY dept_id',
    hints: ['Use GROUP BY to group rows', 'Use COUNT(*) to count rows in each group'],
  },
  {
    id: 'ex-groupby-02',
    moduleId: 'group-by',
    type: 'write-query',
    title: 'Multiple Aggregates',
    description: 'Calculate multiple statistics',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to show for each department: the count of employees, average salary, and maximum salary.',
    answer: 'SELECT dept_id, COUNT(*) AS count, AVG(salary) AS avg_salary, MAX(salary) AS max_salary FROM employees GROUP BY dept_id',
    hints: ['You can use multiple aggregate functions', 'Separate them with commas in the SELECT'],
  },
  {
    id: 'ex-having-01',
    moduleId: 'having',
    type: 'write-query',
    title: 'Filter Groups',
    description: 'Find large departments',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to find departments that have more than 2 employees. Show the department ID and employee count.',
    answer: 'SELECT dept_id, COUNT(*) AS employee_count FROM employees GROUP BY dept_id HAVING COUNT(*) > 2',
    hints: ['Use HAVING to filter groups', 'HAVING comes after GROUP BY', 'You can use aggregate functions in HAVING'],
  },
  {
    id: 'ex-having-02',
    moduleId: 'having',
    type: 'multiple-choice',
    title: 'WHERE vs HAVING',
    description: 'Understanding the difference',
    difficulty: 'easy',
    schema: 'employees',
    question: 'What is the main difference between WHERE and HAVING?',
    options: [
      { id: 'a', text: 'WHERE is faster than HAVING' },
      { id: 'b', text: 'WHERE filters rows before grouping, HAVING filters groups after aggregation' },
      { id: 'c', text: 'They are the same, just different syntax' },
      { id: 'd', text: 'HAVING can only be used with COUNT()' },
    ],
    answer: 'b',
  },
  {
    id: 'ex-subquery-01',
    moduleId: 'subqueries',
    type: 'write-query',
    title: 'Scalar Subquery',
    description: 'Compare to average',
    difficulty: 'hard',
    schema: 'employees',
    question: 'Write a query to find employees who earn more than the average salary across all employees.',
    answer: 'SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees)',
    hints: ['Use a subquery in the WHERE clause', 'The subquery calculates the average', 'Use > to compare'],
  },
  {
    id: 'ex-subquery-02',
    moduleId: 'subqueries',
    type: 'write-query',
    title: 'IN Subquery',
    description: 'Filter by subquery result',
    difficulty: 'hard',
    schema: 'orders',
    question: 'Write a query to find all customers who have placed at least one order. Use a subquery with IN.',
    answer: 'SELECT name FROM customers WHERE id IN (SELECT DISTINCT customer_id FROM orders)',
    hints: ['Use IN with a subquery that returns customer IDs', 'The subquery should select from the orders table'],
  },
  {
    id: 'ex-case-01',
    moduleId: 'case-when',
    type: 'write-query',
    title: 'Salary Categories',
    description: 'Categorize salaries with CASE',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to show employee names and a salary_level column that displays "High" for salaries >= 100000, "Medium" for >= 70000, and "Low" for all others.',
    answer: 'SELECT name, CASE WHEN salary >= 100000 THEN \'High\' WHEN salary >= 70000 THEN \'Medium\' ELSE \'Low\' END as salary_level FROM employees',
    hints: ['Use CASE WHEN for conditional logic', 'Conditions are evaluated top to bottom', 'Always include ELSE for completeness'],
  },
  {
    id: 'ex-case-02',
    moduleId: 'case-when',
    type: 'write-query',
    title: 'Conditional Bonus',
    description: 'Calculate bonuses by department',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to show employee names, salaries, and a bonus column. Bonus should be 10% for dept_id=1, 5% for dept_id=2, and 2% for all others.',
    answer: 'SELECT name, salary, CASE WHEN dept_id = 1 THEN salary * 0.10 WHEN dept_id = 2 THEN salary * 0.05 ELSE salary * 0.02 END as bonus FROM employees',
    hints: ['Use CASE to apply different calculations', 'Multiply salary by the percentage', 'ELSE handles all other departments'],
  },
  {
    id: 'ex-null-01',
    moduleId: 'null-handling',
    type: 'write-query',
    title: 'Find NULL Values',
    description: 'Find employees without departments',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find all employees who do NOT have a department assigned (dept_id is NULL).',
    answer: 'SELECT * FROM employees WHERE dept_id IS NULL',
    hints: ['Use IS NULL to check for NULL values', 'Never use = NULL, it won\'t work!'],
  },
  {
    id: 'ex-null-02',
    moduleId: 'null-handling',
    type: 'write-query',
    title: 'Replace NULL with Default',
    description: 'Use COALESCE for defaults',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to show employee names and dept_id, but display 0 instead of NULL for employees without a department.',
    answer: 'SELECT name, COALESCE(dept_id, 0) as dept_id FROM employees',
    hints: ['COALESCE returns the first non-NULL value', 'Syntax: COALESCE(column, default_value)'],
  },
  {
    id: 'ex-operators-01',
    moduleId: 'in-between-like',
    type: 'write-query',
    title: 'IN Operator',
    description: 'Filter with multiple values',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find employees who work in departments 1, 2, or 3.',
    answer: 'SELECT * FROM employees WHERE dept_id IN (1, 2, 3)',
    hints: ['Use IN operator with a list of values', 'IN is cleaner than multiple OR conditions'],
  },
  {
    id: 'ex-operators-02',
    moduleId: 'in-between-like',
    type: 'write-query',
    title: 'BETWEEN Operator',
    description: 'Find salaries in range',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find employees whose salary is between 70000 and 100000 (inclusive).',
    answer: 'SELECT name, salary FROM employees WHERE salary BETWEEN 70000 AND 100000',
    hints: ['BETWEEN is inclusive of both endpoints', 'BETWEEN x AND y is the same as >= x AND <= y'],
  },
  {
    id: 'ex-operators-03',
    moduleId: 'in-between-like',
    type: 'write-query',
    title: 'LIKE Pattern Matching',
    description: 'Find names with pattern',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to find all employees whose name contains the letter "a" (case-insensitive).',
    answer: 'SELECT * FROM employees WHERE name LIKE \'%a%\'',
    hints: ['% matches zero or more characters', 'Use %pattern% to find substring anywhere', 'LIKE is case-insensitive in SQLite'],
  },
  {
    id: 'ex-string-01',
    moduleId: 'string-functions',
    type: 'write-query',
    title: 'Convert to Uppercase',
    description: 'Transform text with UPPER',
    difficulty: 'easy',
    schema: 'employees',
    question: 'Write a query to show employee names in all uppercase letters.',
    answer: 'SELECT UPPER(name) as name FROM employees',
    hints: ['Use UPPER() function to convert to uppercase', 'LOWER() does the opposite'],
  },
  {
    id: 'ex-string-02',
    moduleId: 'string-functions',
    type: 'write-query',
    title: 'Generate Emails',
    description: 'Concatenate and transform strings',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query to generate email addresses for employees by taking their name, replacing spaces with dots, converting to lowercase, and adding "@company.com".',
    answer: 'SELECT name, LOWER(REPLACE(name, \' \', \'.\')) || \'@company.com\' as email FROM employees',
    hints: ['Use REPLACE to change spaces to dots', 'Use LOWER to make it lowercase', 'Use || to concatenate strings in SQLite'],
  },
  {
    id: 'ex-cte-01',
    moduleId: 'cte-with',
    type: 'write-query',
    title: 'Simple CTE',
    description: 'Use WITH clause for readability',
    difficulty: 'medium',
    schema: 'employees',
    question: 'Write a query using a CTE to first filter high earners (salary > 80000), then select only those in dept_id = 1.',
    answer: 'WITH high_earners AS (SELECT * FROM employees WHERE salary > 80000) SELECT * FROM high_earners WHERE dept_id = 1',
    hints: ['CTE syntax: WITH name AS (query) SELECT ...', 'Define the CTE before the main query', 'Reference the CTE like a table'],
  },
  {
    id: 'ex-cte-02',
    moduleId: 'cte-with',
    type: 'write-query',
    title: 'Multiple CTEs',
    description: 'Use multiple CTEs together',
    difficulty: 'hard',
    schema: 'employees',
    question: 'Write a query using two CTEs: first calculate average salary, then find employees earning more than average. Show name and salary.',
    answer: 'WITH avg_sal AS (SELECT AVG(salary) as avg FROM employees), high_earners AS (SELECT * FROM employees, avg_sal WHERE salary > avg_sal.avg) SELECT name, salary FROM high_earners',
    hints: ['Separate multiple CTEs with commas', 'First CTE calculates average', 'Second CTE compares to that average'],
  },
  {
    id: 'ex-window-01',
    moduleId: 'window-functions',
    type: 'write-query',
    title: 'Rank by Salary',
    description: 'Use ROW_NUMBER window function',
    difficulty: 'hard',
    schema: 'employees',
    question: 'Write a query to show employee names, salaries, and their rank (ROW_NUMBER) ordered by salary descending.',
    answer: 'SELECT name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rank FROM employees',
    hints: ['Use ROW_NUMBER() OVER (ORDER BY ...)', 'OVER clause defines the window', 'DESC means highest salary gets rank 1'],
  },
  {
    id: 'ex-window-02',
    moduleId: 'window-functions',
    type: 'write-query',
    title: 'Partition by Department',
    description: 'Rank within groups',
    difficulty: 'hard',
    schema: 'employees',
    question: 'Write a query to rank employees by salary within each department (PARTITION BY dept_id). Show name, dept_id, salary, and rank.',
    answer: 'SELECT name, dept_id, salary, ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as dept_rank FROM employees WHERE dept_id IS NOT NULL',
    hints: ['PARTITION BY creates separate rankings per group', 'Use PARTITION BY dept_id', 'Ranking resets for each department'],
  },
];
